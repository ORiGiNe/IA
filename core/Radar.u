class Sonar {
	var _s; // le sonar
	var pos; // sa position
	var range; // son champ de vision

	// constructeur
	function init (s, pos, range) {
		_s = s;
		this.pos = pos;
		this.range = range;
	};
	
	function get {
		return _s.get
	};

	// position min visible
	function min {
		return pos - range / 2;
	};
	
	// posisiton max visible
	function max {
		return pos + range / 2;
	};
}|;

class Radar {
	var _sonars = []; // liste des couples (sonar, position)
	var _sonarsMonitored = []; // liste des sonars surveillées
	var _event; // événement émis en cas d'approche
	var _monitorLoop = Tag.new("Monitor Loop"); // tag contenant la loop de monitoring
    var _monitorLoop.update = _monitorLoop.clone; // tag fils
	
	var posMonitored = []; // liste des positions surveillées
    var _oldPosMonitored = []; // pour réagir lors d'un changement de valeur
	var delay = 0.03s; // delai entre deux check des sonars
	var distMin = 20; // distance minimale à l'adversaire que l'on accepte

	var _logRadar = Logger.new("Radar");
	var _logLoop = Logger.new("Monitoring");
	
	// constructeur
	function init (sonars, event) {
        _sonars = sonars;
		_event = event;
		
		// dès que les positions surveillées changent,
        // on met à jour la liste des sonars surveillés
		at (posMonitored != _oldPosMonitored)
		{
			_logRadar.log << "posMonitored mis à jour : " + posMonitored;
			_logRadar.log << "recalcule des sonars à monitorer";
			
			_monitorLoop.stop;
            posMonitored = posMonitored.sort;
			_sonarsMonitored = [];

            // on parcourt toutes les positions surveillées
            for (var pos in posMonitored) {
                // le groupe de sonar a surveiller pour cette position
                // le premier est le sonar principal, les suivants servent à redonder
                var sonarsGroup = [];

                // on regarde s'il y a un sonar dans cette position
                if (pos in _sonars.map(function (s) { s.pos }))
        			for (var sonar in _sonars)
    		    		if (sonar.pos == pos) {
                            // on l'ajoute au groupe
                            sonarsGroup << sonar;

                            // on cherche d'autre sonars pour redonder
                            for (var ssonar in _sonars)
                                if (ssonar != sonar && (ssonar.max >= pos || ssonar.min <= pos))
                                    sonarsGroup << ssonar;
                        
                            break;
                        }
                else {
                    // s'il n'y a pas de sonar dans cette position,
                    // on cherche tous les sonars proches
                    for (var sonar in _sonars)
                        if (sonar.max >= pos || sonar.min <= pos)
                            sonarsGroup << sonar;

                    // on trie cette liste en mettant le plus proche en premier
                    sonarsGroup = sonarsGroup.sort(
                        function (a, b) {
                            (a.pos - pos).abs  < (b.pos - pos).abs
                        })
                };

                if (!sonarsGroup.empty)
                    _sonarsMonitored << sonarsGroup;
            };

            _oldPosMonitored = posMonitored.clone;
			_logRadar.log << "_sonarMonitored : " + _sonarsMonitored.asString;
    		_monitor
		};

		_logRadar.log << "init terminé"
	};

	
	// fonction principale, bloquante (à lancer un tâche de fond)
	function _monitor {
		at (_monitorLoop.leave?)
			_logLoop.log << "They want me to stop";

		_monitorLoop:
		{
			for& (var sonar in _sonarsMonitored) {
				_logLoop.log << "Début de le surveillance";
					
				var distance = sonar[0].get;

				_logLoop.log << "loop de mise à jour des valeurs";

                _monitorLoop.update:
    				every (delay) {
	    				distance = sonar[0].get;
		    			_logLoop.log << "distance = " + distance
			    	},

				_logLoop.log << "démarrage du at";
				var e;
				at (distance < distMin) {
                    // le sonar principale a détecté un adversaire
                    // on vérifie avec les sonars redondants

                    // nécéssaire, je ne sais pas pourquoi
                    var distMin = distMin;
                    if (sonar.foldl(function (a, b) { a && (b.get < distMin) }, true)) {
    					_logLoop.log << "ALERTE !";
	    				e = _event.trigger
                    };
				}
				onleave	{
					_logLoop.log << "FIN DE L'ALERTE";
					e.stop;
				};
			};
		};
	};


	function stop {
        _logLoop.log << "I want you to stop"; 
		_monitorLoop.stop;
	};
}|;
