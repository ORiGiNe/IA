/* PathFinder
 *
 * Trouve un chemin dans une grille (_map)
 * Les obstacles sont représenté par la valeur 1
 * L'algorithme utilisé est A*
 */

class PathFinder {
    var _map;
    var _start; // point de départ
    var _goal; // point visé
    var _closedSet; // noeuds par lesquels ont est déjà passé 
    var _openSet; // noeuds étudiés et disponibles

    var logJ = Logger.new("Jump");
    var logN = Logger.new("getNeighbours");
    var logI = Logger.new("identifySuccessors");
    var logP = Logger.new("pathTo");
    var logH = Logger.new("hasForcedNeighbours");

    function init (map) {
        // la carte DOIT contenir une bordure d'obstacle
        _map = map;
    };


    // retourne la distance de manhattan entre deux points
    function weight (n) {
        (n.dot.x - _goal.x).abs + (n.dot.y - _goal.y).abs;
    };


    /* insère un noeud dans _openSet
     *
     * s'il est déjà dedans, on le met à jour si son nouveau poids est meilleur
     * sinon on l'insère en gardant la liste triée
     */
    function insertOpenSet (n) {
        // si _openSet est vide, c'est assez rapide
        if (_openSet.empty)
            _openSet = [n]
        else {
            /* si le noeud est déjà présent mais que le nouveau poids est moins bien,
            * on ne le réinsère pas
            */
            var insert = true;

            // on regarde si le noeud est déjà présent
            var i = 0;
            for (var e in _openSet) {
                if (e.dot == n.dot)
                    if (e.weight < n.weight) {
                        /* si c'est le cas et que son nouveau poid est meilleur,
                        * on le supprime de la liste pour le réinsérer à sa
                        * bonne place
                        */
                        _openSet = _openSet.filter(
                            function (v) {
                                v.dot != n.dot;
                            });
                        break;
                    }
                    else
                        insert = false;

                i++;
            };

            /* on insère le noeud à la bonne place (à moins qu'il y soit déjà
            * avec un meilleur poids)
            */
            i = 0;
            for (var e in _openSet) {
                if (e.weight >= n.weight && insert) {
                    _openSet.insert(i, n);
                    break;
                };

                i++;
            };
        };
    };


    // obtient le chemin à partir du _closedSet
    function getPath {
        var path = [];
        var current = Node.new;
        current.dot = _goal;

        // on remonte le chemin jusqu'à arriver au point de départ
        while (current.dot != _start) {
            path << current.dot;
            current.dot = _closedSet[current.dot.x][current.dot.y].parent;
        };

        // ne pas oublier le point de départ
        path << _start;

        /* on a remonté le chemin depuis la fin
         * il faut donc l'inverser
         */
        path.reverse;
    };


    // retourne les voisins (après trie) du noeud n
    function getNeighbours (n) {
        var neighbours = [];
        var neighbour = Node.new;
		neighbour.parent = n.dot;
		//logN.log << "My father is " + n.parent;
        //logN.log << "I am his soon, i am " + n.dot;

        if (!n.parent.isNil) {
            var direction = Dot.new(n.dot.x - n.parent.x, n.dot.y - n.parent.y);
            if (direction.x != 0) direction.x /= direction.x.abs;
            if (direction.y != 0) direction.y /= direction.y.abs;
            //logN.log << "I come with " + direction;

            // si on se délpace horizontalement
            if (direction.y == 0) {
                // on pars un coup par le haut, un coup par le bas
                for (var i in [-1, 1]) {
                    neighbour.dot = n.parent;

                    // 1er voisin
                    neighbour.dot.y += i;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                        /* si c'est le cas, les voisins 2 et 3 sont forcés
						 * (si ce ne sont pas des obstacles)
						 */
                        neighbour.dot.x += direction.x;
						if (_map[neighbour.dot.x][neighbour.dot.y] != 1) 
							neighbours << neighbour.copy;

                        neighbour.dot.x += direction.x;
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;
                    }
                    else {
                        // 2ème voisin
                        neighbour.dot.x += direction.x;

                        /* si c'est un obstacle, le 3ème voisin est forcé
            			 * (si ce n'est pas un obstacle)
            			 */
                        if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                            neighbour.dot.x += direction.x;
	                        if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;
                        };
                    };
                };

                // le 7ème noeud est soit un obstacle, soit un voisin
                neighbour.dot = n.parent;
                neighbour.dot.x += 2 * direction.x;

                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour;
            }
            // si on se délpace verticalement
            else if (direction.x == 0) {
                // on pars un coup par la droite, un coup par la gauche
                for (var i in [-1, 1]) {
                    neighbour.dot = n.parent;

                    // 1er voisin
                    neighbour.dot.x += i;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                        // si c'est le cas, les voisins 2 et 3 sont forcés
                        neighbour.dot.y += direction.y;
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;

                        neighbour.dot.y += direction.y;
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;
                    }
                    else {
                        // 2ème voisin
                        neighbour.dot.y += direction.y;

                        // si c'est un obstacle, le 3ème voisin est forcé
                        if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                            neighbour.dot.y += direction.y;
                        
                            if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;
                        };
                    };
                };

                // le 7ème noeud est soit un obstacle, soit un voisin
                neighbour.dot = n.parent;
                neighbour.dot.y += 2 * direction.y;

                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour.copy;
            }
            // si on se déplace en diagonale
            else {
                //logN.log << "So we go in diagonal eh ?";
                // on part du 1er côté
                neighbour.dot = n.parent.clone;
                //logN.log << "We go from " + neighbour.dot.asString;

                // 1er voisin
                neighbour.dot.x += direction.x;
                //logN.log << "Is x1 " + neighbour.dot.asString + " a neighbour ?";

                // si c'est un obstacle, le 2ème voisin est forcé
                if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                    // 2ème voisin
                    neighbour.dot.x += direction.x;
                    //logN.log << "Is x2 " + neighbour.dot.asString + " a neighbour ?";

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                        neighbours << neighbour.copy;
                };

                neighbour.dot = n.parent.clone;

                // le suivant est soit un obstacle, soit un voisin naturel
                neighbour.dot.x += 2 * direction.x;
                neighbour.dot.y += direction.y;
                //logN.log << "Is x3 " + neighbour.dot.asString + " a neighbour ?";
                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour.copy;


                // on part du 2nd côté
                neighbour.dot = n.parent.clone;
                //logN.log << "Ok, now let's try the other side. We are back on " + neighbour.dot;

                // 1er voisin
                neighbour.dot.y += direction.y;
                //logN.log << "Is y1 " + neighbour.dot.asString + " a neighbour ?";

                // si c'est un obstacle, le 2ème voisin est forcé
                if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                    // 2ème voisin
                    neighbour.dot.y += direction.y;
                    //logN.log << "Is y2 " + neighbour.dot.asString + " a neighbour ?";

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 1)
                        neighbours << neighbour.copy;
                };                   
                
                neighbour.dot = n.parent.clone;

                // celui-ci est soit un obstacle, soit un voisin naturel
                neighbour.dot.y += 2 * direction.y;
                neighbour.dot.x += direction.x;
                //logN.log << "Is y3 " + neighbour.dot.asString + " a neighbour ?";
                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour.copy;

                // enfin le dernier, soit obstacle soit voisin naturel
                neighbour.dot.x += direction.x;
                //logN.log << "Is the last one " + neighbour.dot.asString + " a neighbour ?";
                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour.copy;
            };
        }
        else {
            /* si on a pas de parent, c'est qu'on est au départ
             * on garde tous les voisins
             */
            for (var i in [-1,0,1]) {
                for (var j in [-1,0,1]) {
                    // on vérifie qu'on est bien sur un voisin
                    if (i != 0 || j != 0) {
                        neighbour.dot = n.dot + Dot.new(i,j);

                        // on vérifie que ce n'est pas un obstacle
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                            neighbours << neighbour.copy;
                    };
                };
            };
        };

        neighbours;
    };


	/* permet de savoir si n à des voisins forcés
     * on arrive depuis la direction d
     */
	function hasForcedNeighbours(n, d) {
        //logH.log << n.dot.asString + " has forced neighbours ?";

        //logH.log << "his parent is " + (n.dot - d);

		// si on se déplace verticalement
		if (d.x == 0)
			// on pars d'abord par la gauche, puis par la droite
			for (var i in [-1, 1]) {
                // noeud depuis lequel on arrive
        		var node = n.dot - d;

				// on se décale dans la direction en cours
				node.x += i;
                //logH.log << "OK, I'm testing " + node;
				// si le 2ème voisin est un obstacle
				if (_map[node.x][node.y + d.y] == 1) {
                    //logH.log << "WHY THIS APPENDS TO ME ????!!!!";
					// si le 3ème voisin n'est pas obstacle
					if (_map[node.x][node.y + 2 * d.y] != 1)
						// alors c'est un voisin forcé
						return true;
				}
				// sinon si le 1er voisin est un obstacle
				else if (_map[node.x][node.y] == 1)
					// alors le 2ème voisin est un obstacle
					return true;
			}
		// si on se déplace horizontalement
		else if (d.y == 0)
			for (var i in [-1, 1]) {
                // noeud depuis lequel on arrive
        		var node = n.dot - d;

                node.y += i;
                
                // si le 2ème voisin est un obstacle
                if (_map[node.x + d.x][node.y] == 1) {
                    // si le 3ème voisin n'est pas obstacle
                    if (_map[node.x + 2 * d.x][node.y] != 1)
                        // alors c'est un voisin forcé
                        return true;
		}
                // sinon si le 1er voisin est un obstacle
                else if (_map[node.x][node.y] == 1)
                    // alors le 2ème voisin est un obstacle
                    return true;
			}
		// si on se déplace en diagonale
		else {
            // noeud depuis lequel on arrive
    		var node = n.dot - d;

			if (_map[node.x + d.x][node.y] == 1 && _map[node.x + 2 * d.x][node.y] == 0)
				// si le 1er voisin est un obstacle et pas le 3ème, ce dernier est forcé
				return true
			else if (_map[node.x][node.y + d.y] == 1 && _map[node.x][node.y + 2 * d.y] == 0)
				// idem dans l'autre direction
				return true;
        };

		false;
	};


	// trouve à partir de n le prochain point intéressant dans la direction d
	function jump (n, d) {
		var node = n.copy;
		node.dot += d;

        loop {
		    //logJ.log << "Jump from " + n.dot + " in direction " + d + " to " + node.dot.asString + " wich is …";

		    /* si c'est un obstacle, ce n'est pas vraiment intéressant (se prendre des
		    * murs !)
		    */
		    if (_map[node.dot.x][node.dot.y] == 1)
                { //logJ.log << "… an obstacle";
			    return nil;};

		    // si c'est le but, c'est plutôt intéressant (enfin il paraît …)
		    if (node.dot == _goal)
                { //logJ.log << "… the goal !";
			    return node;};

		    // s'il a au moins un voisin forcé, il est intéressant
		    if (hasForcedNeighbours(node,d))
			    { //logH.log << "Yes ! It has !";
                //logJ.log << "… " + n.dot;
			    return node; };

            //logH.log << "No, it's just a asshole";

		    /* si on arrive en diagonal, en check à la verticale et à l'horizontale
		    * (vers l'avant toujours)
		    */
		    if (d.x != 0 && d.y != 0) {
                //logJ.log << "A diagonal ? I like that.";
                //logJ.log << "Ok, let's try in the direction " + d.x;
                var a = jump(node, Dot.new(d.x,0));

                if (!a.isNil)
                    { //logJ.log << "… " + n.dot + " because he have forced neighbours";
			        return node;};

                //logJ.log << "Wath in the direction " + d.y;
                var b = jump(node, Dot.new(0,d.y));
    		    if (!b.isNil)
	        	    { //logJ.log << "… " + n.dot + " because he have forced neighbours";
			        return node;};
		    };

            //logJ.log << "… not interesting. Let's go forward.";
		    node.dot += d;
        };
	};


	// obtient à partir d'une liste de voisins les successeurs du noeud n
	function identifySuccessors(neighbours, n) {
		var successors = [];

		for (var node in neighbours) {
			//logI.log << "Is " + node.dot + " a successor ?";
			var direction = Dot.new(node.dot.x - n.dot.x, node.dot.y - n.dot.y);
            if (direction.x != 0) direction.x /= direction.x.abs;
            if (direction.y != 0) direction.y /= direction.y.abs;
            //logI.log << "My direction is " + direction;
			var successor = jump(n, direction);

			if (!successor.isNil) {
				//logI.log << "yes ! " + node.dot + " is a successor";
				successors << node };
		};

		successors;
	};


    // trouve le chemin de start à goal dans la map _map avec A*
    function pathTo (start, goal) {
        _start = start;
        _goal = goal;

        // noeud où l'on se situe
        var current = Node.new;

        /* initialisation :
         * on part du point de départ (seems legit)
         */
        current.dot = _start;
        current.weight = weight(current);
        current.distance = 0;

        /* _openSet est une liste de Node, tandis que _closedSet est une map
         * 
         * Cela permet de retrouver plus facilement un noeud précis dans
         * _closedSet alors que l'on prendra toujours le premier élément de
         * _openSet.
         */
        _openSet = [current];
        _closedSet = Matrix.new(_map.x, _map.y, nil);

        // si _openSet est vide, c'est qu'on a épuisé toutes les possibilités
        while (!_openSet.empty) {
            //logP.log << "========================================================";
            /* on se déplace sur le noeud de meilleur poids
             * (_openSet étant trié)
             */
            current = _openSet.front;

            // on check si on est arrivé
            if (current.dot == _goal) {
                _closedSet[_goal.x][_goal.y] = current;
                return getPath;
            };

            // on supprime le noeud sur lequel on est des noeuds disponibles
            _openSet = _openSet.tail;

            /* on ajoute le noeuds actuel dans la liste des noeuds par lesquels
             * on est déjà passé
             */
            _closedSet[current.dot.x][current.dot.y] = current;

            // on cherche ses voisins
            var neighbours = getNeighbours(current);
			//logP.log << "neighbours = " + neighbours.clone.map(function(v){v.dot});
		    var successors = identifySuccessors(neighbours, current);
			//logP.log << "successors = " + successors.clone.map(function(v){v.dot});

			for (var node in successors) {
                //logP.log << "OK let's insert " + node.dot;
				node.parent = current.dot;
				node.distance = current.distance + 1;
				node.weight = node.distance + weight(node);
				insertOpenSet(node);
			};

            //logP.log << "openSet = " + _openSet.clone.map(function(v){v.dot});
        };

        // on a épuisé les possibilités, il n'existe pas de chemin
        [];
    };
};
