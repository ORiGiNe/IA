/* PathFinder
 *
 * Trouve un chemin dans une grille (map)
 * Les obstacles sont représenté par la valeur 1
 * L'algorithme utilisé est A*
 */

class PathFinder {
    var _map;
    var _start; // point de départ
    var _goal; // point visé
    var _closedSet; // noeuds par lesquels ont est déjà passé 
    var _openSet; // noeuds étudiés et disponibles 

    function init (map) {
        _map = map;
    };


    /* calcul le poid d'un noeud
     * on utilise la distance de manhattan
     */
    function weight (n) {
        (n.x - _goal.x).abs + (n.y - _goal.y).abs;
    };


    /* insère un noeud dans _openSet
     *
     * s'il est déjà dedans, on le met à jour si son nouveau poids est meilleur
     * sinon on l'insère en gardant la liste triée
     */
    function insertOpenSet (n) {
        /* si le noeud est déjà présent mais que le nouveau poids est moins bien,
         * on ne le réinsère pas
         */
        var insert = true;

        // on regarde si le noeud est déjà présent
        var i = 0;
        for (var e in _openSet) {
            if (e.dot == n.dot)
                if (e.weight < n.weight) {
                    /* si c'est le cas et que son nouveau poid est meilleur,
                     * on le supprime de la liste pour le réinsérer à sa
                     * bonne place
                     */
                    _openSet = _openSet.filter(
                        function (v) {
                            v.dot != n.dot;
                        });
                    break;
                }
                else
                    insert = false;

            i++;
        };

        /* on insère le noeud à la bonne place (à moins qu'il y soit déjà
         * avec un meilleur poids)
         */
        i = 0;
        for (var e in _openSet) {
            if (e.weight >= n.weight && insert) {
                _openSet.insert(i, n);
                break;
            };
        };
    };


    // obtient le chemin à partir du _closedSet
    function getPath {
        var path = [];
        var current = Node.new;
        current.dot = _goal;

        // on remonte le chemin jusqu'à arriver au point de départ
        while (current.dot != _start) {
            path << current.dot;
            current.dot = _closedSet[current.dot.x][current.dot.y].parent;
        };

        /* on a remonté le chemin depuis la fin
         * il faut donc l'inverser
         */
        path.reverse;
    };


    // trouve le chemin de start à goal dans la map _map avec A*
    function pathTo (start, goal) {
        _start = start;
        _goal = goal;

        // noeud où l'on se situe
        var current = Node.new;

        // noeud voision que l'on étudie
        var neighbour;

        /* initialisation :
         * on part du point de départ (seems legit)
         */
        current.dot = _start;
        current.weight = weight(current.dot);
        current.distance = 0;

        /* _openSet est une liste de Node, tandis que _closedSet est une map
         * 
         * Cela permet de retrouver plus facilement un noeud précis dans
         * _closedSet alors que l'on prendra toujours le premier élément de
         * _openSet.
         */
        _openSet = [current];
        _closedSet = Matrix.new(_map.x, _map.y, nil);

        // si _openSet est vide, c'est qu'on a épuisé toutes les possibilités
        while (!_openSet.empty) {
            /* on se déplace sur le noeud de meilleur poids
             * (_openSet étant trié)
             */
            current = _openSet.front;

            // on check si on est arrivé
            if (current.dot == _goal) {
                _closedSet[_goal.x][_goal.y] = current;
                return getPath;
            };

            // on supprime le noeud sur lequel on est des noeuds disponibles
            _openSet = _openSet.tail;

            // on étudie ses voisins
            for (var i in [-1,0,1]) {
                for (var j in [-1,0,1]) {
                    // on vérifie qu'on est bien sur un noeud voisin
                    if (i == 0 && j == 0)
                        continue;

                    neighbour = Node.new;
                    neighbour.dot = current.dot + Dot.new(i,j);

                    // on vérifie qu'on ne sort pas de la map
                    if (neighbour.dot.x < 0 || neighbour.dot.y < 0 ||
                        neighbour.dot.x >= _map.x || neighbour.dot.y >= _map.y) {
                        continue;
                    };
                   
                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 1)
                        continue;

                    // on regarde si on est déjà passé par ce noeud
                    if (!_closedSet[neighbour.dot.x][neighbour.dot.y].isNil)
                        continue;

                    // calcul du poids du noeud étudié
                    neighbour.weight = weight(neighbour.dot) + current.distance + 1;
                    neighbour.distance = current.distance + 1;

                    /* on enregsitre par où on a accédé à ce noeud afin de
                     * pouvoir remonter le chemin plus tard
                     */
                    neighbour.parent = current.dot;

                    // on insère le noeud dans la liste des noeuds disponibles
                    if (_openSet.empty)
                        _openSet = [neighbour]
                    else
                        insertOpenSet(neighbour);
                };
            };

            /* on ajoute le noeuds actuel dans la liste des noeuds par lesquels
             * on est déjà passé
             */
            _closedSet[current.dot.x][current.dot.y] = current;
        };

        // on a épuisé les possibilités, il n'existe pas de chemin
        [];
    };
};
