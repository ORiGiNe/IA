/* PathFinder
 *
 * Trouve un chemin dans une grille (_map)
 * Les obstacles sont représenté par la valeur 1
 * L'algorithme utilisé est A*
 */

class PathFinder {
    var _map;
    var _start; // point de départ
    var _goal; // point visé
    var _closedSet; // noeuds par lesquels ont est déjà passé 
    var _openSet; // noeuds étudiés et disponibles

    function init (map) {
        // la carte DOIT contenir une bordure d'obstacle
        _map = map;
    };


    // retourne la distance de manhattan entre deux points
    function weight (n) {
        (n.dot.x - _goal.x).abs + (n.dot.y - _goal.y).abs;
    };


    /* insère un noeud dans _openSet
     *
     * s'il est déjà dedans, on le met à jour si son nouveau poids est meilleur
     * sinon on l'insère en gardant la liste triée
     */
    function insertOpenSet (n) {
        /* si le noeud est déjà présent mais que le nouveau poids est moins bien,
         * on ne le réinsère pas
         */
        var insert = true;

        // on regarde si le noeud est déjà présent
        var i = 0;
        for (var e in _openSet) {
            if (e.dot == n.dot)
                if (e.weight < n.weight) {
                    /* si c'est le cas et que son nouveau poid est meilleur,
                     * on le supprime de la liste pour le réinsérer à sa
                     * bonne place
                     */
                    _openSet = _openSet.filter(
                        function (v) {
                            v.dot != n.dot;
                        });
                    break;
                }
                else
                    insert = false;

            i++;
        };

        /* on insère le noeud à la bonne place (à moins qu'il y soit déjà
         * avec un meilleur poids)
         */
        i = 0;
        for (var e in _openSet) {
            if (e.weight >= n.weight && insert) {
                _openSet.insert(i, n);
                break;
            };

            i++;
        };
    };


    // obtient le chemin à partir du _closedSet
    function getPath {
        var path = [];
        var current = Node.new;
        current.dot = _goal;

        // on remonte le chemin jusqu'à arriver au point de départ
        while (current.dot != _start) {
            path << current.dot;
            current.dot = _closedSet[current.dot.x][current.dot.y].parent;
        };

        // ne pas oublier le point de départ
        path << _start;

        /* on a remonté le chemin depuis la fin
         * il faut donc l'inverser
         */
        path.reverse;
    };


    // retourne les voisins (après trie) du noeud n
    function getNeighbours (n) {
        var neighbours = [];
        var neighbour = Node.new;
		neighbour.parent = n.dot;
		echo("My father is " + neighbour.parent);

        if (!n.parent.isNil) {
            var direction = Dot.new(n.dot.x - n.parent.x, n.dot.y - n.parent.y);

            // si on se délpace horizontalement
            if (direction.y == 0) {
                // on pars un coup par le haut, un coup par le bas
                for (var i in [-1, 1]) {
                    neighbour.dot = n.parent;

                    // 1er voisin
                    neighbour.dot.y += i;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                        /* si c'est le cas, les voisins 2 et 3 sont forcés
						 * (si ce ne sont pas des obstacles)
						 */
                        neighbour.dot.x += direction.x;
						if (_map[neighbour.dot.x][neighbour.dot.y] != 1) 
							neighbours << neighbour.copy;

                        neighbour.dot.x += direction.x;
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;
                    }
                    else {
                        // 2ème voisin
                        neighbour.dot.x += direction.x;

                        /* si c'est un obstacle, le 3ème voisin est forcé
			 * (si ce n'est pas un obstacle
			 */
                        if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                            neighbour.dot.x += direction.x;
	                    if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;
                        };
                    };
                };

                // le 7ème noeud est soit un obstacle, soit un voisin
                neighbour.dot = n.parent;
                neighbour.x += 2 * direction.x;

                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour;
            }
            // si on se délpace verticalement
            else if (direction.x == 0) {
                // on pars un coup par la droite, un coup par la gauche
                for (var i in [-1, 1]) {
                    neighbour.dot = n.parent;

                    // 1er voisin
                    neighbour.dot.x += i;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                        // si c'est le cas, les voisins 2 et 3 sont forcés
                        neighbour.dot.y += direction.y;
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;

                        neighbour.dot.y += direction.y;
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;
                    }
                    else {
                        // 2ème voisin
                        neighbour.dot.y += direction.y;

                        // si c'en un obstacle, le 3ème voisin est forcé
                        if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                            neighbour.dot.y += direction.y;
                            if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                                neighbours << neighbour.copy;
                        };
                    };
                };

                // le 7ème noeud est soit un obstacle, soit un voisin
                neighbour.dot = n.parent;
                neighbour.y += 2 * direction.y;

                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour.copy;
            }
            // si on se déplace en diagonale
            else {
                // on part du 1er côté
                neighbour.dot = n.parent;

                // 1er voisin
                neighbour.dot.x += direction.x;

                // si c'est un obstacle, le 2ème voisin est forcé
                if (_map[neighbour.dot.x][neighbour.dot.y] == 0) {
                    // 2ème voisin
                    neighbour.dot.x += direction.x;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 0)
                        neighbours << neighbour.copy;

                    // le suivant est soit un obstacle, soit un voisin naturel
                    neighbour.dot.y += direction.y;
                    if (_map[neighbour.dot.x][neighbour.dot.y] != 0)
                        neighbours << neighbour.copy;
                 };

                // on part du 2nd côté
                neighbour.dot = n.parent;

                // 1er voisin
                neighbour.dot.y += direction.y;

                // si c'est un obstacle, le 2ème voisin est forcé
                if (_map[neighbour.dot.x][neighbour.dot.y] == 0) {
                    // 2ème voisin
                    neighbour.dot.y += direction.y;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 0)
                        neighbours << neighbour.copy;
                    
                    // celui-ci est soit un obstacle, soit un voisin naturel
                    neighbour.dot.x += direction.x;
                    if (_map[neighbour.dot.x][neighbour.dot.y] != 0)
                        neighbours << neighbour.copy;

                    // enfin le dernier, soit obstacle soit voisin naturel
                    neighbour.dot.x += direction.x;
                    if (_map[neighbour.dot.x][neighbour.dot.y] != 0)
                        neighbours << neighbour.copy;
                };
            };
        }
        else {
            /* si on a pas de parent, c'est qu'on est au départ
             * on garde tous les voisins
             */
            for (var i in [-1,0,1]) {
                for (var j in [-1,0,1]) {
                    // on vérifie qu'on est bien sur un voisin
                    if (i != 0 || j != 0) {
                        neighbour.dot = n.dot + Dot.new(i,j);

                        // on vérifie que ce n'est pas un obstacle
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 0)
                            neighbours << neighbour.copy;
                    };
                };
            };
        };

        neighbours;
    };


	// permet de savoir si n à des voisins forcés
	function hasForcedNeighbours(n) {
		var node = n.parent;
		var direction = Dot.new(n.dot.x - node.x, n.dot.y - node.y);

		// si on se déplace verticalement
		if (direction.x == 0)
			// on pars d'abord par la gauche, puis par la droite
			for (i in [-1, 1]) {
				// on se décale dans la direction en cours
				node.dot.x += i;

				// si le 2ème voisin est un obstacle
				if (_map[node.x][node.y + direction.y] == 1) {
					// si le 3ème voisin n'est pas obstacle
					if (_map[node.x][node.y + 2 * direction.y] != 1)
						// alors c'est un voisin forcé
						return true;
				}
				// sinon si le 1er voisin est un obstacle
				else if (_map[node.x][node.y] != 1)
					// alors le 2ème voisin est un obstacle
					return true;
			}
		// si on se déplace horizontalement
		else if (direction.y == 0)
			for (var i in [-1, 1]) {
                node.y += i;
                
                // si le 2ème voisin est un obstacle
                if (_map[node.x + direction.x][node.y] == 1) {
                    // si le 3ème voisin n'est pas obstacle
                    if (_map[node.x + 2 * direction.x][node.y] != 1)
                        // alors c'est un voisin forcé
                        return true;
		}
                // sinon si le 1er voisin est un obstacle
                else if (_map[node.x][node.y] != 1)
                    // alors le 2ème voisin est un obstacle
                    return true;
			}
		// si on se déplace en diagonale
		else
			if (_map[node.x + direction.x][node.y] == 1 && _map[node.x + 2 * direction.x][node.y] == 0)
				// si le 1er voisin est un obstacle et pas le 3ème, ce dernier est forcé
				return true
			else if (_map[node.x][node.y + direction.y] == 1 && _map[node.x][node.y + 2 * direction.y] == 0)
				// idem dans l'autre direction
				return true;

		false;
	};


	// trouve à partir de n le prochain point intéressant dans la direction d
	function jump (n, d) {
		echo("Jump from " + n.dot + " to …");	
		var node = n.clone;
		node.dot += d;

		/* si c'est un obstacle, ce n'est pas vraiment intéressant (se prendre des
		 * murs !)
		 */
		if (_map[node.dot.x][node.dot.y] == 0)
			return nil;

		// si c'est le but, c'est plutôt intéressant (enfin il paraît …)
		if (node.dot == _goal)
			return node;

		// s'il a au moins un voisin forcé, il est intéressant
		if (hasForcedNeighbours(n))
			{ echo (n.dot);
			return n; };

		/* si on arrive en diagonal, en check à la verticale et à l'horizontale
		 * (vers l'avant toujours)
		 */
		if (d.x != 0 && d.y != 0)
			for (2) {
				if ( !jump(node, Dot.new(d.x,0)).isNil || !jump(node, Dot.new(0,d.y).isNil))
					{ echo(n.dot);
					return n;};
			};

		return jump(node, d);
	};


	// obtient à partir d'une liste de voisins les successeurs du noeud n
	function identifySuccessors(neighbours, n) {
		var successors = [];

		for (var node in neighbours) {
			echo ("Is " + node.dot + " a successor ?");
			var direction = Dot.new(node.dot.x - n.dot.x, node.dot.y - n.dot.y);
			var successor = jump(node, direction);

			if (!successor.isNil) {
				echo("yes !");
				successors << node };
		};

		successors;
	};


    // trouve le chemin de start à goal dans la map _map avec A*
    function pathTo (start, goal) {
        _start = start;
        _goal = goal;

        // noeud où l'on se situe
        var current = Node.new;

        /* initialisation :
         * on part du point de départ (seems legit)
         */
        current.dot = _start;
        current.weight = weight(current);
        current.distance = 0;

        /* _openSet est une liste de Node, tandis que _closedSet est une map
         * 
         * Cela permet de retrouver plus facilement un noeud précis dans
         * _closedSet alors que l'on prendra toujours le premier élément de
         * _openSet.
         */
        _openSet = [current];
        _closedSet = Matrix.new(_map.x, _map.y, nil);

        // si _openSet est vide, c'est qu'on a épuisé toutes les possibilités
        while (!_openSet.empty) {
            /* on se déplace sur le noeud de meilleur poids
             * (_openSet étant trié)
             */
            current = _openSet.front;

            // on check si on est arrivé
            if (current.dot == _goal) {
                _closedSet[_goal.x][_goal.y] = current;
                return getPath;
            };

            // on supprime le noeud sur lequel on est des noeuds disponibles
            _openSet = _openSet.tail;

            /* on ajoute le noeuds actuel dans la liste des noeuds par lesquels
             * on est déjà passé
             */
            _closedSet[current.dot.x][current.dot.y] = current;

            // on cherche ses voisins
            var neighbours = getNeighbours(current);
			echo ("neighbours = " + neighbours);
		    var successors = identifySuccessors(neighbours, current);
			echo ("successors = " + successors);

			for (var node in successors) {
				node.parent = current.dot;
				node.distance = current.distance + 1;
				node.weight = node.distance + weight(node);
				_openSet << node;
			};
        };

        // on a épuisé les possibilités, il n'existe pas de chemin
        [];
    };
};
