/* PathFinder
 *
 * Trouve un chemin dans une grille (_map)
 * Les obstacles sont représenté par la valeur 1
 * L'algorithme utilisé est A*
 */

class PathFinder {
    var _map;
    var _start; // point de départ
    var _goal; // point visé
    var _closedSet; // noeuds par lesquels ont est déjà passé 
    var _openSet; // noeuds étudiés et disponibles

    function init (map) {
        // la carte DOIT contenir une bordure d'obstacle
        _map = map;
    };


    // retourne la distance de manhattan entre deux points
    function weight (n) {
        (n.dot.x - _goal.x).abs + (n.dot.y - _goal.y).abs;
    };


    /* insère un noeud dans _openSet
     *
     * s'il est déjà dedans, on le met à jour si son nouveau poids est meilleur
     * sinon on l'insère en gardant la liste triée
     */
    function insertOpenSet (n) {
        /* si le noeud est déjà présent mais que le nouveau poids est moins bien,
         * on ne le réinsère pas
         */
        var insert = true;

        // on regarde si le noeud est déjà présent
        var i = 0;
        for (var e in _openSet) {
            if (e.dot == n.dot)
                if (e.weight < n.weight) {
                    /* si c'est le cas et que son nouveau poid est meilleur,
                     * on le supprime de la liste pour le réinsérer à sa
                     * bonne place
                     */
                    _openSet = _openSet.filter(
                        function (v) {
                            v.dot != n.dot;
                        });
                    break;
                }
                else
                    insert = false;

            i++;
        };

        /* on insère le noeud à la bonne place (à moins qu'il y soit déjà
         * avec un meilleur poids)
         */
        i = 0;
        for (var e in _openSet) {
            if (e.weight >= n.weight && insert) {
                _openSet.insert(i, n);
                break;
            };

            i++;
        };
    };


    // obtient le chemin à partir du _closedSet
    function getPath {
        var path = [];
        var current = Node.new;
        current.dot = _goal;

        // on remonte le chemin jusqu'à arriver au point de départ
        while (current.dot != _start) {
            path << current.dot;
            current.dot = _closedSet[current.dot.x][current.dot.y].parent;
        };

        // ne pas oublier le point de départ
        path << _start;

        /* on a remonté le chemin depuis la fin
         * il faut donc l'inverser
         */
        path.reverse;
    };


    // retourne les voisins (après trie) du noeud n
    function getNeighbours (n) {
        var neighbours = [];
        var neighbour = Node.new;
        neighbour.parent = n.dot;

        if (!n.parent.isNil) {
            var direction = Dot.new(n.dot.x - n.parent.x, n.dot.y - n.parent.y);

            // si on se délpace horizontalement
            if (direction.y == 0) {
                // on pars un coup par le haut, un coup par le bas
                for (var i in [-1, 1]) {
                    neighbour.dot = n.parent;

                    // 1er voisin
                    neighbour.dot.y += i;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                        // si c'est le cas, les voisins 2 et 3 sont forcés
                        neighbour.dot.x += direction.x;
                        neighbours << neighbour;
                        neighbour.dot.x += direction.x;
                        neighbours << neighbour;
                    }
                    else {
                        // 2ème voisin
                        neighbour.dot.x += direction.x;

                        // si c'en un obstacle, le 3ème voisin est forcé
                        if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                            neighbour.dot.x += direction.x;
                            neighbours << neighbour;
                        };
                    };
                };

                // le 7ème noeud est soit un obstacle, soit un voisin
                neighbour.dot = n.parent;
                neighbour.x += 2 * direction.x;

                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour;
            }
            // si on se délpace verticalement
            else if (direction.x == 0) {
                // on pars un coup par la droite, un coup par la gauche
                for (var i in [-1, 1]) {
                    neighbour.dot = n.parent;

                    // 1er voisin
                    neighbour.dot.x += i;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                        // si c'est le cas, les voisins 2 et 3 sont forcés
                        neighbour.dot.y += direction.y;
                        neighbours << neighbour;
                        neighbour.dot.y += direction.y;
                        neighbours << neighbour;
                    }
                    else {
                        // 2ème voisin
                        neighbour.dot.y += direction.y;

                        // si c'en un obstacle, le 3ème voisin est forcé
                        if (_map[neighbour.dot.x][neighbour.dot.y] == 1) {
                            neighbour.dot.y += direction.y;
                            neighbours << neighbour;
                        };
                    };
                };

                // le 7ème noeud est soit un obstacle, soit un voisin
                neighbour.dot = n.parent;
                neighbour.y += 2 * direction.y;

                if (_map[neighbour.dot.x][neighbour.dot.y] != 1)
                    neighbours << neighbour;
            }
            // si on se déplace en diagonale
            else {
                // on part du 1er côté
                neighbour.dot = n.parent;

                // 1er voisin
                neighbour.dot.x += direction.x;

                // si c'est un obstacle, le 2ème voisin est forcé
                if (_map[neighbour.dot.x][neighbour.dot.y] == 0) {
                    // 2ème voisin
                    neighbour.dot.x += direction.x;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 0)
                        neighbours << neighbour;

                    // celui-ci est soit un obstacle, soit un voisin naturel
                    neighbour.dot.y += direction.y;
                    if (_map[neighbour.dot.x][neighbour.dot.y] != 0)
                        neighbours << neighbour;
                 };

                // on part du 2nd côté
                neighbour.dot = n.parent;

                // 1er voisin
                neighbour.dot.y += direction.y;

                // si c'est un obstacle, le 2ème voisin est forcé
                if (_map[neighbour.dot.x][neighbour.dot.y] == 0) {
                    // 2ème voisin
                    neighbour.dot.y += direction.y;

                    // on vérifie que ce n'est pas un obstacle
                    if (_map[neighbour.dot.x][neighbour.dot.y] == 0)
                        neighbours << neighbour;
                    
                    // celui-ci est soit un obstacle, soit un voisin naturel
                    neighbour.dot.x += direction.x;
                    if (_map[neighbour.dot.x][neighbour.dot.y] != 0)
                        neighbours << neighbour;

                    // enfin le dernier, soit obstacle soit voisin naturel
                    neighbour.dot.x += direction.x;
                    if (_map[neighbour.dot.x][neighbour.dot.y] != 0)
                        neighbours << neighbour;
                };
            };
        }
        else {
            /* si on a pas de parent, c'est qu'on est au départ
             * on garde tous les voisins
             */
            for (var i in [-1,0,1]) {
                for (var j in [-1,0,1]) {
                    // on vérifie qu'on est bien sur un voisin
                    if (i != 0 || j != 0) {
                        neighbour.dot = n.dot + Dot.new(i,j);

                        // on vérifie que ce n'est pas un obstacle
                        if (_map[neighbour.dot.x][neighbour.dot.y] != 0)
                            neighbours << neighbour;
                    };
                };
            };
        };

        neighbours;
    };


    // trouve le chemin de start à goal dans la map _map avec A*
    function pathTo (start, goal) {
        _start = start;
        _goal = goal;

        // noeud où l'on se situe
        var current = Node.new;

        /* initialisation :
         * on part du point de départ (seems legit)
         */
        current.dot = _start;
        current.weight = weight(current);
        current.distance = 0;

        /* _openSet est une liste de Node, tandis que _closedSet est une map
         * 
         * Cela permet de retrouver plus facilement un noeud précis dans
         * _closedSet alors que l'on prendra toujours le premier élément de
         * _openSet.
         */
        _openSet = [current];
        _closedSet = Matrix.new(_map.x, _map.y, nil);

        // si _openSet est vide, c'est qu'on a épuisé toutes les possibilités
        while (!_openSet.empty) {
            /* on se déplace sur le noeud de meilleur poids
             * (_openSet étant trié)
             */
            current = _openSet.front;

            // on check si on est arrivé
            if (current.dot == _goal) {
                _closedSet[_goal.x][_goal.y] = current;
                return getPath;
            };

            // on supprime le noeud sur lequel on est des noeuds disponibles
            _openSet = _openSet.tail;

            /* on ajoute le noeuds actuel dans la liste des noeuds par lesquels
             * on est déjà passé
             */
            _closedSet[current.dot.x][current.dot.y] = current;

            // on cherche ses voisins
            var neighbours = getNeighbours(current);
        };

        // on a épuisé les possibilités, il n'existe pas de chemin
        [];
    };
};
